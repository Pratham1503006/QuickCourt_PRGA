{"version":3,"file":"bookingService-Ba80icv2.js","sources":["../../src/services/bookingService.js"],"sourcesContent":["// Booking service for managing reservations and availability\r\nimport { db } from './database';\r\n\r\n// Always use mock mode since we removed Supabase\r\nconst isMockMode = () => true;\r\n\r\nclass BookingService {\r\n  constructor() {\r\n    this.mockMode = isMockMode();\r\n  }\r\n\r\n  // Create a new booking\r\n  async createBooking(bookingData) {\r\n    try {\r\n      // Validate booking data\r\n      this.validateBookingData(bookingData);\r\n\r\n      // Check venue availability\r\n      const isAvailable = await this.checkAvailability(\r\n        bookingData.venueId,\r\n        bookingData.bookingDate,\r\n        bookingData.startTime,\r\n        bookingData.endTime\r\n      );\r\n\r\n      if (!isAvailable) {\r\n        throw new Error('Selected time slot is not available');\r\n      }\r\n\r\n      // Calculate pricing\r\n      const pricing = await this.calculatePricing(bookingData);\r\n      \r\n      const bookingWithPricing = {\r\n        ...bookingData,\r\n        baseAmount: pricing.baseAmount,\r\n        additionalCharges: pricing.additionalCharges,\r\n        discountAmount: pricing.discountAmount,\r\n        totalAmount: pricing.totalAmount,\r\n        durationHours: this.calculateDuration(bookingData.startTime, bookingData.endTime)\r\n      };\r\n\r\n      // Create the booking\r\n      const booking = await db.createBooking(bookingWithPricing);\r\n      \r\n      // Send confirmation notification (in real app)\r\n      await this.sendBookingNotification(booking, 'created');\r\n\r\n      return { booking, error: null };\r\n    } catch (error) {\r\n      console.error('Error creating booking:', error);\r\n      return { booking: null, error };\r\n    }\r\n  }\r\n\r\n  // Get user's bookings with optional filters\r\n  async getUserBookings(userId, filters = {}) {\r\n    try {\r\n      const bookings = await db.getUserBookings(userId, filters);\r\n      return { bookings, error: null };\r\n    } catch (error) {\r\n      console.error('Error fetching user bookings:', error);\r\n      return { bookings: [], error };\r\n    }\r\n  }\r\n\r\n  // Get specific booking details\r\n  async getBookingById(bookingId) {\r\n    try {\r\n      const booking = await db.getBookingById(bookingId);\r\n      if (!booking) {\r\n        throw new Error('Booking not found');\r\n      }\r\n      return { booking, error: null };\r\n    } catch (error) {\r\n      console.error('Error fetching booking:', error);\r\n      return { booking: null, error };\r\n    }\r\n  }\r\n\r\n  // Update booking status\r\n  async updateBookingStatus(bookingId, status, userId, reason = null) {\r\n    try {\r\n      const booking = await db.getBookingById(bookingId);\r\n      if (!booking) {\r\n        throw new Error('Booking not found');\r\n      }\r\n\r\n      // Check permissions\r\n      if (booking.userId !== userId && booking.venue?.ownerId !== userId) {\r\n        throw new Error('Not authorized to update this booking');\r\n      }\r\n\r\n      // Validate status transition\r\n      if (!this.isValidStatusTransition(booking.status, status)) {\r\n        throw new Error(`Cannot change status from ${booking.status} to ${status}`);\r\n      }\r\n\r\n      const updateData = {\r\n        status,\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n\r\n      if (status === 'cancelled') {\r\n        updateData.cancellationReason = reason;\r\n        updateData.cancelledAt = new Date().toISOString();\r\n      } else if (status === 'confirmed') {\r\n        updateData.confirmedAt = new Date().toISOString();\r\n      } else if (status === 'completed') {\r\n        updateData.completedAt = new Date().toISOString();\r\n      }\r\n\r\n      // In a real app, this would update the database\r\n      const updatedBooking = { ...booking, ...updateData };\r\n      \r\n      // Send notification\r\n      await this.sendBookingNotification(updatedBooking, status);\r\n\r\n      return { booking: updatedBooking, error: null };\r\n    } catch (error) {\r\n      console.error('Error updating booking status:', error);\r\n      return { booking: null, error };\r\n    }\r\n  }\r\n\r\n  // Check availability for a specific venue and time slot\r\n  async checkAvailability(venueId, date, startTime, endTime) {\r\n    try {\r\n      return await db.checkVenueAvailability(venueId, date, startTime, endTime);\r\n    } catch (error) {\r\n      console.error('Error checking availability:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Get available time slots for a venue on a specific date\r\n  async getAvailableSlots(venueId, date) {\r\n    try {\r\n      const venue = await db.getVenueById(venueId);\r\n      if (!venue) {\r\n        throw new Error('Venue not found');\r\n      }\r\n\r\n      // Get the day of week\r\n      const dayOfWeek = new Date(date).toLocaleDateString('en-US', { weekday: 'long' }).toLowerCase();\r\n      const operatingHours = venue.operatingHours?.[dayOfWeek];\r\n      \r\n      if (!operatingHours) {\r\n        return { slots: [], error: null };\r\n      }\r\n\r\n      // Generate time slots (1-hour intervals)\r\n      const slots = this.generateTimeSlots(operatingHours.open, operatingHours.close);\r\n      \r\n      // Check availability for each slot\r\n      const availableSlots = [];\r\n      for (const slot of slots) {\r\n        const isAvailable = await this.checkAvailability(\r\n          venueId,\r\n          date,\r\n          slot.start,\r\n          slot.end\r\n        );\r\n        \r\n        availableSlots.push({\r\n          ...slot,\r\n          available: isAvailable\r\n        });\r\n      }\r\n\r\n      return { slots: availableSlots, error: null };\r\n    } catch (error) {\r\n      console.error('Error getting available slots:', error);\r\n      return { slots: [], error };\r\n    }\r\n  }\r\n\r\n  // Calculate booking pricing\r\n  async calculatePricing(bookingData) {\r\n    try {\r\n      const venue = await db.getVenueById(bookingData.venueId);\r\n      if (!venue) {\r\n        throw new Error('Venue not found');\r\n      }\r\n\r\n      const duration = this.calculateDuration(bookingData.startTime, bookingData.endTime);\r\n      let baseAmount = venue.pricePerHour * duration;\r\n\r\n      // Sport-specific pricing (if available)\r\n      if (bookingData.sportId) {\r\n        // In a real app, get sport-specific pricing from venue_sports table\r\n        // For now, use base venue pricing\r\n      }\r\n\r\n      // Calculate additional charges\r\n      let additionalCharges = 0;\r\n      if (bookingData.amenities) {\r\n        // Add charges for paid amenities\r\n        // This would query venue_amenities table in real app\r\n      }\r\n\r\n      // Calculate discounts\r\n      let discountAmount = 0;\r\n      if (bookingData.discountCode) {\r\n        // Apply discount codes\r\n        // This would query a discounts table in real app\r\n      }\r\n\r\n      const totalAmount = baseAmount + additionalCharges - discountAmount;\r\n\r\n      return {\r\n        baseAmount,\r\n        additionalCharges,\r\n        discountAmount,\r\n        totalAmount: Math.max(0, totalAmount) // Ensure non-negative\r\n      };\r\n    } catch (error) {\r\n      console.error('Error calculating pricing:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Helper methods\r\n  validateBookingData(data) {\r\n    const required = ['userId', 'venueId', 'bookingDate', 'startTime', 'endTime'];\r\n    for (const field of required) {\r\n      if (!data[field]) {\r\n        throw new Error(`Missing required field: ${field}`);\r\n      }\r\n    }\r\n\r\n    // Validate date is not in the past\r\n    const bookingDate = new Date(data.bookingDate);\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n    \r\n    if (bookingDate < today) {\r\n      throw new Error('Cannot book dates in the past');\r\n    }\r\n\r\n    // Validate time format and logic\r\n    if (data.startTime >= data.endTime) {\r\n      throw new Error('End time must be after start time');\r\n    }\r\n\r\n    // Validate minimum booking duration (e.g., 1 hour)\r\n    const duration = this.calculateDuration(data.startTime, data.endTime);\r\n    if (duration < 1) {\r\n      throw new Error('Minimum booking duration is 1 hour');\r\n    }\r\n  }\r\n\r\n  calculateDuration(startTime, endTime) {\r\n    const start = new Date(`2000-01-01T${startTime}`);\r\n    const end = new Date(`2000-01-01T${endTime}`);\r\n    return (end - start) / (1000 * 60 * 60); // Convert to hours\r\n  }\r\n\r\n  generateTimeSlots(openTime, closeTime, intervalHours = 1) {\r\n    const slots = [];\r\n    const start = new Date(`2000-01-01T${openTime}`);\r\n    const end = new Date(`2000-01-01T${closeTime}`);\r\n    \r\n    let current = new Date(start);\r\n    \r\n    while (current < end) {\r\n      const slotStart = current.toTimeString().substring(0, 5);\r\n      current.setHours(current.getHours() + intervalHours);\r\n      \r\n      if (current <= end) {\r\n        const slotEnd = current.toTimeString().substring(0, 5);\r\n        slots.push({\r\n          start: slotStart,\r\n          end: slotEnd,\r\n          duration: intervalHours\r\n        });\r\n      }\r\n    }\r\n    \r\n    return slots;\r\n  }\r\n\r\n  isValidStatusTransition(currentStatus, newStatus) {\r\n    const validTransitions = {\r\n      pending: ['confirmed', 'cancelled'],\r\n      confirmed: ['completed', 'cancelled'],\r\n      cancelled: [], // Cannot change from cancelled\r\n      completed: [] // Cannot change from completed\r\n    };\r\n\r\n    return validTransitions[currentStatus]?.includes(newStatus) || false;\r\n  }\r\n\r\n  async sendBookingNotification(booking, action) {\r\n    try {\r\n      // In a real app, this would send emails/SMS notifications\r\n      console.log(`Booking notification: ${action}`, booking);\r\n      \r\n      let title, message;\r\n      \r\n      switch (action) {\r\n        case 'created':\r\n          title = 'Booking Created';\r\n          message = `Your booking at ${booking.venueName} is pending confirmation.`;\r\n          break;\r\n        case 'confirmed':\r\n          title = 'Booking Confirmed';\r\n          message = `Your booking at ${booking.venueName} has been confirmed for ${booking.bookingDate}.`;\r\n          break;\r\n        case 'cancelled':\r\n          title = 'Booking Cancelled';\r\n          message = `Your booking at ${booking.venueName} has been cancelled.`;\r\n          break;\r\n        case 'completed':\r\n          title = 'Booking Completed';\r\n          message = `Thanks for visiting ${booking.venueName}! Please leave a review.`;\r\n          break;\r\n        default:\r\n          return;\r\n      }\r\n\r\n      // In mock mode, just log the notification\r\n      if (this.mockMode) {\r\n        console.log('Mock notification:', { title, message });\r\n        return;\r\n      }\r\n\r\n      // In real app, save to notifications table and send via email/SMS\r\n      // await db.createNotification({\r\n      //   userId: booking.userId,\r\n      //   title,\r\n      //   message,\r\n      //   type: 'booking',\r\n      //   data: { bookingId: booking.id }\r\n      // });\r\n\r\n    } catch (error) {\r\n      console.error('Error sending booking notification:', error);\r\n    }\r\n  }\r\n\r\n  // Get booking statistics for dashboard\r\n  async getBookingStats(userId, userRole = 'customer') {\r\n    try {\r\n      let stats = {\r\n        total: 0,\r\n        confirmed: 0,\r\n        pending: 0,\r\n        cancelled: 0,\r\n        completed: 0\r\n      };\r\n\r\n      if (userRole === 'customer') {\r\n        const { bookings } = await this.getUserBookings(userId);\r\n        stats.total = bookings.length;\r\n        \r\n        bookings.forEach(booking => {\r\n          stats[booking.status] = (stats[booking.status] || 0) + 1;\r\n        });\r\n      }\r\n\r\n      return { stats, error: null };\r\n    } catch (error) {\r\n      console.error('Error getting booking stats:', error);\r\n      return { stats: {}, error };\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const bookingService = new BookingService();\r\nexport default bookingService;\r\n"],"names":["isMockMode","BookingService","bookingData","pricing","bookingWithPricing","booking","db","error","userId","filters","bookingId","status","reason","_a","updateData","updatedBooking","venueId","date","startTime","endTime","venue","dayOfWeek","operatingHours","slots","availableSlots","slot","isAvailable","duration","baseAmount","additionalCharges","discountAmount","totalAmount","data","required","field","bookingDate","today","start","openTime","closeTime","intervalHours","end","current","slotStart","slotEnd","currentStatus","newStatus","action","title","message","userRole","stats","bookings","bookingService"],"mappings":"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"}