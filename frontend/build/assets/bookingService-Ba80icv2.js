import{d as c}from"./index-DS6X6zkM.js";const d=()=>!0;class g{constructor(){this.mockMode=d()}async createBooking(e){try{if(this.validateBookingData(e),!await this.checkAvailability(e.venueId,e.bookingDate,e.startTime,e.endTime))throw new Error("Selected time slot is not available");const o=await this.calculatePricing(e),r={...e,baseAmount:o.baseAmount,additionalCharges:o.additionalCharges,discountAmount:o.discountAmount,totalAmount:o.totalAmount,durationHours:this.calculateDuration(e.startTime,e.endTime)},i=await c.createBooking(r);return await this.sendBookingNotification(i,"created"),{booking:i,error:null}}catch(t){return console.error("Error creating booking:",t),{booking:null,error:t}}}async getUserBookings(e,t={}){try{return{bookings:await c.getUserBookings(e,t),error:null}}catch(o){return console.error("Error fetching user bookings:",o),{bookings:[],error:o}}}async getBookingById(e){try{const t=await c.getBookingById(e);if(!t)throw new Error("Booking not found");return{booking:t,error:null}}catch(t){return console.error("Error fetching booking:",t),{booking:null,error:t}}}async updateBookingStatus(e,t,o,r=null){var i;try{const n=await c.getBookingById(e);if(!n)throw new Error("Booking not found");if(n.userId!==o&&((i=n.venue)==null?void 0:i.ownerId)!==o)throw new Error("Not authorized to update this booking");if(!this.isValidStatusTransition(n.status,t))throw new Error(`Cannot change status from ${n.status} to ${t}`);const a={status:t,updatedAt:new Date().toISOString()};t==="cancelled"?(a.cancellationReason=r,a.cancelledAt=new Date().toISOString()):t==="confirmed"?a.confirmedAt=new Date().toISOString():t==="completed"&&(a.completedAt=new Date().toISOString());const s={...n,...a};return await this.sendBookingNotification(s,t),{booking:s,error:null}}catch(n){return console.error("Error updating booking status:",n),{booking:null,error:n}}}async checkAvailability(e,t,o,r){try{return await c.checkVenueAvailability(e,t,o,r)}catch(i){return console.error("Error checking availability:",i),!1}}async getAvailableSlots(e,t){var o;try{const r=await c.getVenueById(e);if(!r)throw new Error("Venue not found");const i=new Date(t).toLocaleDateString("en-US",{weekday:"long"}).toLowerCase(),n=(o=r.operatingHours)==null?void 0:o[i];if(!n)return{slots:[],error:null};const a=this.generateTimeSlots(n.open,n.close),s=[];for(const l of a){const u=await this.checkAvailability(e,t,l.start,l.end);s.push({...l,available:u})}return{slots:s,error:null}}catch(r){return console.error("Error getting available slots:",r),{slots:[],error:r}}}async calculatePricing(e){try{const t=await c.getVenueById(e.venueId);if(!t)throw new Error("Venue not found");const o=this.calculateDuration(e.startTime,e.endTime);let r=t.pricePerHour*o;e.sportId;let i=0;e.amenities;let n=0;e.discountCode;const a=r+i-n;return{baseAmount:r,additionalCharges:i,discountAmount:n,totalAmount:Math.max(0,a)}}catch(t){throw console.error("Error calculating pricing:",t),t}}validateBookingData(e){const t=["userId","venueId","bookingDate","startTime","endTime"];for(const n of t)if(!e[n])throw new Error(`Missing required field: ${n}`);const o=new Date(e.bookingDate),r=new Date;if(r.setHours(0,0,0,0),o<r)throw new Error("Cannot book dates in the past");if(e.startTime>=e.endTime)throw new Error("End time must be after start time");if(this.calculateDuration(e.startTime,e.endTime)<1)throw new Error("Minimum booking duration is 1 hour")}calculateDuration(e,t){const o=new Date(`2000-01-01T${e}`);return(new Date(`2000-01-01T${t}`)-o)/(1e3*60*60)}generateTimeSlots(e,t,o=1){const r=[],i=new Date(`2000-01-01T${e}`),n=new Date(`2000-01-01T${t}`);let a=new Date(i);for(;a<n;){const s=a.toTimeString().substring(0,5);if(a.setHours(a.getHours()+o),a<=n){const l=a.toTimeString().substring(0,5);r.push({start:s,end:l,duration:o})}}return r}isValidStatusTransition(e,t){var r;return((r={pending:["confirmed","cancelled"],confirmed:["completed","cancelled"],cancelled:[],completed:[]}[e])==null?void 0:r.includes(t))||!1}async sendBookingNotification(e,t){try{console.log(`Booking notification: ${t}`,e);let o,r;switch(t){case"created":o="Booking Created",r=`Your booking at ${e.venueName} is pending confirmation.`;break;case"confirmed":o="Booking Confirmed",r=`Your booking at ${e.venueName} has been confirmed for ${e.bookingDate}.`;break;case"cancelled":o="Booking Cancelled",r=`Your booking at ${e.venueName} has been cancelled.`;break;case"completed":o="Booking Completed",r=`Thanks for visiting ${e.venueName}! Please leave a review.`;break;default:return}if(this.mockMode){console.log("Mock notification:",{title:o,message:r});return}}catch(o){console.error("Error sending booking notification:",o)}}async getBookingStats(e,t="customer"){try{let o={total:0,confirmed:0,pending:0,cancelled:0,completed:0};if(t==="customer"){const{bookings:r}=await this.getUserBookings(e);o.total=r.length,r.forEach(i=>{o[i.status]=(o[i.status]||0)+1})}return{stats:o,error:null}}catch(o){return console.error("Error getting booking stats:",o),{stats:{},error:o}}}}const f=new g;export{f as bookingService,f as default};
//# sourceMappingURL=bookingService-Ba80icv2.js.map
